# Chapter 13: 서브클래싱과 서브타이핑

## 상속의 용도
1. **타입 계층 구현**
   - **부모 클래스**: 일반적인 개념을 구현 (일반화)
   - **자식 클래스**: 특수한 개념을 구현 (특수화)

2. **코드 재사용**
   - 부모와 자식 클래스 간의 결합도가 높아질 수 있어 설계의 변경과 진화를 방해할 수 있음.


## 타입
- **개념 관점**: 공통의 특징을 공유하는 대상들의 분류.
- **프로그래밍 언어 관점**: 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합.

- 객체의 **퍼블릭 인터페이스**가 객체의 타입을 결정함.
- 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류됨.


## 슈퍼타입과 서브타입
1. **슈퍼타입**
   - 두 타입 간의 관계에서 더 일반적인 타입.
   - 집합이 다른 집합의 모든 멤버를 포함하며, 타입 정의가 더 일반적임.

2. **서브타입**
   - 두 타입 간의 관계에서 더 특수한 타입.
   - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함되며, 타입 정의가 더 구체적임.


## 상속을 사용할 때 고려해야 할 점
1. **상속 관계가 is-a 관계인가?**
   - “자식 클래스는 부모 클래스다”라고 말해도 이상하지 않다면, 상속을 사용할 후보로 간주할 수 있음.

2. **클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?**
   - 클라이언트는 부모 클래스와 자식 클래스의 차이점을 몰라야 함.

> **Tip**: 1보다 2에 초점을 맞추어야 함.  
> 타입 계층의 의미는 **행동의 문맥**에 따라 달라질 수 있음.  
> 두 타입 간 행동이 호환되는 경우에만 타입 계층으로 묶어야 함.


## 인터페이스 분리 원칙 (ISP)
- 인터페이스를 **클라이언트의 기대**에 따라 분리하여, 변경에 의해 영향을 제어하는 설계 원칙.


## 서브클래싱과 서브타이핑
1. **서브클래싱 (구현 상속, 클래스 상속)**
   - 다른 클래스의 코드를 **재사용**할 목적으로 상속을 사용하는 경우.
   - 자식 클래스와 부모 클래스의 행동이 **호환되지 않음**.
   - 자식 클래스가 부모 클래스를 **대체할 수 없음**.

2. **서브타이핑 (인터페이스 상속)**
   - **타입 계층**을 구성하기 위해 상속을 사용하는 경우.
   - 자식 클래스와 부모 클래스의 행동이 **호환됨**.
   - 자식 클래스가 부모 클래스를 **대체할 수 있음**.


## 리스코프 치환 원칙 (LSP)
- **자식 클래스가 클라이언트 관점에서 부모 클래스를 대체할 수 있어야 함.**
- 기능 확장을 위해 자식 클래스를 추가하더라도 기존 코드를 수정할 필요가 없어야 함.
- **LSP**는 **개방-폐쇄 원칙 (OCP)**을 만족하는 설계의 전제 조건임.


## 서브타입 설계 조건
1. 서브타입은 슈퍼타입보다 **더 강력한 사전조건**을 정의할 수 없음.
2. 서브타입은 슈퍼타입보다 **같거나 더 약한 사전조건**을 정의할 수 있음.
3. 서브타입은 슈퍼타입보다 **같거나 더 강한 사후조건**을 정의할 수 있음.
4. 서브타입은 슈퍼타입보다 **더 약한 사후조건**을 정의할 수 없음.
