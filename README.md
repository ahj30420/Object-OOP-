# 오브젝트 (객체지향 프로그래밍 정리)

## Chapter 01: 객체, 설계

### 소프트웨어 모듈의 세 가지 목적 (로버트 마틴)
1. **정확한 동작**: 소프트웨어 모듈은 실행 중에 올바르게 작동해야 한다.
2. **변경 용이성**: 모듈은 변경을 위해 존재한다. 대부분의 모듈은 생명주기 동안 변경되므로, 쉽게 수정할 수 있어야 한다.
3. **이해 용이성**: 코드를 읽는 사람이 쉽게 이해할 수 있어야 한다.

### 의존성(결합도)과 변경
- **의존성**은 변경의 영향을 암시한다. 한 객체가 변경되면, 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다.

### 객체지향 설계 원칙
- 객체를 **인터페이스**와 **구현**으로 나누고, **인터페이스만을 공개**하여 결합도를 낮추고 변경하기 쉬운 코드를 작성하는 것이 중요하다.
- 핵심은 **객체 내부의 상태를 캡슐화**하고, 객체 간에 **메시지를 통해 상호작용**하도록 하는 것이다.

### 응집도와 위임
- 밀접하게 연관된 작업만 수행하고, 관련이 없는 작업은 다른 객체에 위임하는 객체를 **응집도가 높다**고 한다.

### 절차적 프로그래밍과 객체지향 프로그래밍의 차이
- **절차적 프로그래밍**: 프로세스(메서드)와 데이터를 별도의 모듈에 위치시키는 방식.
- **객체지향 프로그래밍**: 프로세스와 데이터를 동일한 모듈에 위치시키고, 객체를 중심으로 프로그래밍하는 방식.
    - 예시: `step01`은 `Theater`의 `enter` 메서드가 프로세스이고, `Audience`, `TicketSeller`, `Bag`, `TicketOffice`는 데이터로서 별도의 모듈에 위치하게 된다. 따라서 `step01`은 절차적 프로그래밍이다.

---

## Chapter 02: 객체지향 프로그래밍

### 객체지향 프로그래밍의 두 가지 핵심 원칙
1. **객체 우선**: 어떤 클래스를 만들지 고민하기 전에, **어떤 객체들이 필요한지**를 먼저 고민해야 한다.
2. **객체의 협력**: 객체를 **독립적인 존재**로 보기보다는 **기능을 협력하여 구현하는 공동체의 일원**으로 보아야 한다.

### 자율적인 객체
1. 객체는 **상태**와 **행동**을 함께 가지는 **복합적인 존재**이다.
2. 객체는 **스스로 판단**하고 **행동하는 자율적인 존재**이다.

### 캡슐화와 접근 제어
- **퍼블릭 인터페이스**: 외부에서 접근 가능한 부분 (public)
- **구현**: 외부에서 접근 불가능하고 내부에서만 접근 가능한 부분 (private, protected)

### 프로그래머의 역할
1. **클래스 작성자**: 새로운 데이터 타입을 추가하는 역할.
2. **클라이언트 프로그래머**: 클래스 작성자가 추가한 데이터 타입을 사용해 애플리케이션을 구축하는 역할.

### 구현 은닉
- **구현 은닉**은 클래스 작성자가 클라이언트 프로그래머가 접근할 수 없는 부분을 숨김으로써, **내부 구현을 자유롭게 변경**할 수 있게 한다.
- **외부와 내부**를 명확히 구분하면 클라이언트 프로그래머가 알아야 할 지식이 줄어들고, 클래스 작성자의 **구현 변경 자유도**가 높아진다.

### 코드 의존성과 실행 시점 의존성
- **코드 의존성**(컴파일 시간 의존성)과 **실행 시점 의존성**(실행 시간 의존성)은 서로 다를 수 있다.
- **유연하고 재사용 가능한 설계**는 코드 의존성과 실행 시점 의존성의 차이에 의해 가능해진다.
- 그러나, 이 차이가 커질수록 코드를 이해하기 어려워진다는 **트레이드오프**가 존재한다.

### 다형성과 바인딩
- **다형성**: 동일한 메시지를 전송해도, 실제로 어떤 메서드가 실행될지는 **수신 객체의 클래스**에 따라 달라진다. 이는 컴파일 시간과 실행 시간 의존성을 다르게 만든다.
- **동적 바인딩**(지연 바인딩): 메시지와 메서드를 **실행 시점에 바인딩**하는 것.
- **정적 바인딩**(초기 바인딩): **컴파일 시점에 실행할 메서드**가 결정되는 것.

### 상속의 단점
1. **캡슐화를 위반**할 수 있다.
2. **설계의 유연성을 저해**한다 (부모-자식 클래스의 관계가 컴파일 시점에 결정됨).

### 합성 vs 상속
- **상속**: 클래스를 통해 강하게 결합됨.
- **합성**: 메시지를 통해 느슨하게 결합됨.
- **코드 재사용**을 위해서는 **상속보다 합성**이 더 유연하지만, **다형성**을 위해서는 **상속과 합성을 조합**해서 사용할 수 있다.
