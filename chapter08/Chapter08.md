# Chapter 08: 의존성 관리하기

## 의존성의 의미
- **실행 시점**: 의존하는 객체가 정상적으로 동작하기 위해, 의존 대상 객체가 실행 시 반드시 존재해야 함.
- **구현 시점**: 의존 대상 객체가 변경되면, 의존하는 객체도 함께 변경됨.

유연하고 재사용 가능한 코드를 설계하기 위해서는 **컴파일타임 의존성**과 **런타임 의존성**을 다르게 설계해야 한다.

클래스가 사용될 특정 문맥에 대해 최소한의 가정만으로 이뤄져 있으면, 다른 문맥에서 **재사용성**이 더 높아지는데 이를 **컨텍스트 독립성**이라고 한다.

## 의존성 해결 방법
1. **생성자 주입**
2. **Setter 주입**
    - 장점: 실행 시점에 의존 대상을 변경할 수 있어 설계가 유연해짐.
    - 단점: 객체 생성 후 의존 대상이 설정되기 전까지 객체 상태가 불완전할 수 있음.
    - **생성자 주입**과 함께 사용하는 것을 추천함.
3. **메서드 주입**
    - 사용 시점: 지속적인 의존 관계가 필요 없고 일시적으로만 의존하는 경우.
    - 메서드 실행마다 의존 대상이 매번 달라지는 경우.
    - 대부분의 경우에는 **생성자 주입**이나 **Setter 주입**이 더 적합.

## 바람직한 의존성
- 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면, 그 의존성은 바람직하지 못함.

## 결합도를 느슨하게 만드는 의존성
1. **인터페이스 의존성**
2. **추상 클래스 의존성**
3. **구체 클래스 의존성**

## 명시적 의존성 vs. 숨겨진 의존성
- **명시적 의존성**이 없으면, 의존성을 파악하기 위해 내부 구현을 살펴봐야 함.
- 숨겨진 의존성은 클래스를 재사용하기 어렵게 만들고 잠재적 버그를 발생시킬 수 있음.
- **명시적 의존성**을 통해 컴파일타임 의존성을 적절히 런타임 의존성으로 교체하면, 유연하고 재사용 가능한 설계를 할 수 있음.

## 객체 내부의 new 생성자는 결합도를 높인다
- **new 생성자**는 객체 생성에 필요한 인자와 순서를 알아야 하므로 결합도를 높임.
- 객체 간 **결합도를 낮추기** 위해 인스턴스 생성의 책임을 클라이언트로 옮기고, 객체는 **인스턴스 사용의 책임**만 남겨야 함.
- **사용**과 **생성의 책임**을 분리하는 것이 중요!
