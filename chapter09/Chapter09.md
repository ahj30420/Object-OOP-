# Chapter 09: 유연한 설계

## 개방-폐쇄 원칙 (OCP, Open-Closed Principle)
- **확장에 열려있어야 한다**: 애플리케이션은 요구사항이 변경될 때 새로운 동작을 추가하여 기능을 확장할 수 있어야 함.
- **수정에는 닫혀있어야 한다**: 기존 코드를 수정하지 않고도 새로운 동작을 추가하거나 변경할 수 있어야 함.

## 객체의 책임 분리
- **객체 생성과 사용을 분리**해야 함.
    - **생성** 책임과 **사용** 책임이 하나의 객체에 있으면, 변경 시 영향을 줄 가능성이 커짐.

## 팩토리 패턴 (Factory Pattern)
- 객체의 생성과 사용을 분리하기 위해, 객체 생성에 특화된 객체(Factory)를 사용.
- **Factory 객체**는 의존성을 해결하는 데 도움을 줌으로써 유연하고 재사용 가능한 설계를 가능하게 함.

## 시스템 분해 방식
1. **표현적 분해 (Representational Decomposition)**
    - 도메인에 존재하는 사물이나 개념을 객체로 표현하여 시스템을 분해하는 방식.

2. **행위적 분해 (Behavioral Decomposition)**
    - 설계자의 편의에 따라 만들어진 순수한 가공물(Pure Fabrication)을 사용하여 시스템을 분해.

## 의존성 주입 (Dependency Injection)
- 외부의 독립적인 객체가 필요한 인스턴스를 생성하고 이를 주입하여 의존성을 해결하는 방식.

### 의존성 주입 방식
1. **생성자 주입**
2. **Setter 주입**
    - **장점**: 의존 대상을 언제든 교체할 수 있음.
    - **단점**: 객체가 완전한 상태로 생성되지 않을 수 있음. 의존성이 필수임을 명시할 수 없고, 호출 누락 시 문제가 발생할 수 있음.
3. **메서드 주입**
    - 특정 메서드에서만 의존성이 필요할 때 사용.

## 숨겨진 의존성의 문제
- **문제점 발생 시점**이 컴파일타임에서 런타임으로 미루어짐.
- **독립적인 단위 테스트 작성이 어려워짐**.
- **캡슐화가 약화**되어 코드 이해와 수정이 어려워짐.
- 의존성을 명확히 드러낼수록 코드를 이해하고 수정하기 쉬워짐.

## 의존성 역전 원칙 (Dependency Inversion Principle)
- **상위 수준의 모듈은 하위 수준 모듈에 의존하지 않음**. 둘 다 추상화에 의존해야 함.
- **추상화는 구체적인 사항에 의존하지 않음**. 오히려 구체적인 사항이 추상화에 의존해야 함.

