# Chapter 11: 합성과 유연한 설계

## 상속을 코드 재사용으로 사용했을 경우의 문제점
1. **불필요한 인터페이스 상속 문제**  
   필요한 기능만 사용하려 해도 부모 클래스의 모든 인터페이스를 상속받아야 하는 문제가 발생함.

2. **메서드 오버라이딩의 오작용 문제**  
   부모 메서드를 자식 클래스에서 오버라이딩할 때, 의도치 않은 동작을 발생시킬 위험이 있음.

3. **부모 클래스와 자식 클래스의 동시 수정 문제**  
   부모 클래스의 변경이 필요할 경우, 자식 클래스까지 모두 수정해야 할 수 있음.

4. **클래스 추가 및 수정의 복잡성**  
   기능 하나를 추가하거나 수정하기 위해 여러 클래스의 추가 및 수정을 요구할 수 있음.

5. **단일 상속의 한계**  
   단일 상속만 지원하는 언어에서는 상속의 제약으로 인해 중복 코드가 오히려 증가하는 문제를 겪을 수 있음.

- **해결 방안**: 상속의 단점을 합성(Composition)을 통해 개선할 수 있음.

## 합성으로 해결하기

- **포워딩(Forwarding)**  
  오버라이딩한 인스턴스 메서드에서 내부의 인스턴스에게 동일한 메서드 호출을 전달하는 방식.  
  기존 클래스의 인터페이스를 외부에 그대로 제공하면서, 내부 구현에 대한 결합 없이 작동 방식을 일부 변경할 수 있음.

- **훅 메서드(Hook Method)**  
  추상 메서드와 유사하게 자식 클래스에서 오버라이딩할 수 있도록 기본 구현을 제공하는 메서드.  
  자식 클래스에서 선택적으로 오버라이딩하여 구현을 수정하거나 확장 가능.

## 상속의 한계와 합성을 통한 해결
- **클래스 폭발 문제**:  
  상속을 남용하면 하나의 기능을 추가할 때 불필요하게 많은 클래스를 생성해야 하는 문제 발생.

- **유연한 설계**  
  컴파일 타임과 런타임 의존성 사이의 거리가 멀수록 설계는 더 유연해짐.
    - **상속**: 컴파일 타임 의존성과 런타임 의존성이 동일하여 부모와 자식 클래스의 관계가 정적으로 고정됨. 실행 시점에 관계를 동적으로 변경하기 어려움.
    - **합성**: 런타임에 객체 간의 관계를 유연하게 설정할 수 있어, 의존성이 낮고 유연한 설계를 가능하게 함.
