# 오브젝트 (객체지향 프로그래밍 정리)

## Chapter 01: 객체, 설계

### 소프트웨어 모듈의 세 가지 목적 (로버트 마틴)
1. **정확한 동작**: 소프트웨어 모듈은 실행 중에 올바르게 작동해야 한다.
2. **변경 용이성**: 모듈은 변경을 위해 존재한다. 대부분의 모듈은 생명주기 동안 변경되므로, 쉽게 수정할 수 있어야 한다.
3. **이해 용이성**: 코드를 읽는 사람이 쉽게 이해할 수 있어야 한다.

### 의존성(결합도)과 변경
- **의존성**은 변경의 영향을 암시한다. 한 객체가 변경되면, 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다.

### 객체지향 설계 원칙
- 객체를 **인터페이스**와 **구현**으로 나누고, **인터페이스만을 공개**하여 결합도를 낮추고 변경하기 쉬운 코드를 작성하는 것이 중요하다.
- 핵심은 **객체 내부의 상태를 캡슐화**하고, 객체 간에 **메시지를 통해 상호작용**하도록 하는 것이다.

### 응집도와 위임
- 밀접하게 연관된 작업만 수행하고, 관련이 없는 작업은 다른 객체에 위임하는 객체를 **응집도가 높다**고 한다.

### 절차적 프로그래밍과 객체지향 프로그래밍의 차이
- **절차적 프로그래밍**: 프로세스(메서드)와 데이터를 별도의 모듈에 위치시키는 방식.
- **객체지향 프로그래밍**: 프로세스와 데이터를 동일한 모듈에 위치시키고, 객체를 중심으로 프로그래밍하는 방식.
    - 예시: `step01`은 `Theater`의 `enter` 메서드가 프로세스이고, `Audience`, `TicketSeller`, `Bag`, `TicketOffice`는 데이터로서 별도의 모듈에 위치하게 된다. 따라서 `step01`은 절차적 프로그래밍이다.

---

## Chapter 02: 객체지향 프로그래밍

### 객체지향 프로그래밍의 두 가지 핵심 원칙
1. **객체 우선**: 어떤 클래스를 만들지 고민하기 전에, **어떤 객체들이 필요한지**를 먼저 고민해야 한다.
2. **객체의 협력**: 객체를 **독립적인 존재**로 보기보다는 **기능을 협력하여 구현하는 공동체의 일원**으로 보아야 한다.

### 자율적인 객체
1. 객체는 **상태**와 **행동**을 함께 가지는 **복합적인 존재**이다.
2. 객체는 **스스로 판단**하고 **행동하는 자율적인 존재**이다.

### 캡슐화와 접근 제어
- **퍼블릭 인터페이스**: 외부에서 접근 가능한 부분 (public)
- **구현**: 외부에서 접근 불가능하고 내부에서만 접근 가능한 부분 (private, protected)

### 프로그래머의 역할
1. **클래스 작성자**: 새로운 데이터 타입을 추가하는 역할.
2. **클라이언트 프로그래머**: 클래스 작성자가 추가한 데이터 타입을 사용해 애플리케이션을 구축하는 역할.

### 구현 은닉
- **구현 은닉**은 클래스 작성자가 클라이언트 프로그래머가 접근할 수 없는 부분을 숨김으로써, **내부 구현을 자유롭게 변경**할 수 있게 한다.
- **외부와 내부**를 명확히 구분하면 클라이언트 프로그래머가 알아야 할 지식이 줄어들고, 클래스 작성자의 **구현 변경 자유도**가 높아진다.

### 코드 의존성과 실행 시점 의존성
- **코드 의존성**(컴파일 시간 의존성)과 **실행 시점 의존성**(실행 시간 의존성)은 서로 다를 수 있다.
- **유연하고 재사용 가능한 설계**는 코드 의존성과 실행 시점 의존성의 차이에 의해 가능해진다.
- 그러나, 이 차이가 커질수록 코드를 이해하기 어려워진다는 **트레이드오프**가 존재한다.

### 다형성과 바인딩
- **다형성**: 동일한 메시지를 전송해도, 실제로 어떤 메서드가 실행될지는 **수신 객체의 클래스**에 따라 달라진다. 이는 컴파일 시간과 실행 시간 의존성을 다르게 만든다.
- **동적 바인딩**(지연 바인딩): 메시지와 메서드를 **실행 시점에 바인딩**하는 것.
- **정적 바인딩**(초기 바인딩): **컴파일 시점에 실행할 메서드**가 결정되는 것.

### 상속의 단점
1. **캡슐화를 위반**할 수 있다.
2. **설계의 유연성을 저해**한다 (부모-자식 클래스의 관계가 컴파일 시점에 결정됨).

### 합성 vs 상속
- **상속**: 클래스를 통해 강하게 결합됨.
- **합성**: 메시지를 통해 느슨하게 결합됨.
- **코드 재사용**을 위해서는 **상속보다 합성**이 더 유연하지만, **다형성**을 위해서는 **상속과 합성을 조합**해서 사용할 수 있다.

---

## Chapter 03: 역할, 책임, 협력

### 협력
- 객체지향 시스템은 **자율적인 객체들의 공동체**이다.
- **협력**은 객체지향 세계에서 기능을 구현할 수 있는 **유일한 방법**이다.
- 협력은 **하나의 객체가 다른 객체에게 도움을 요청**하면서 시작되며, **메시지 전송**이 협력의 유일한 커뮤니케이션 수단이다.
- 협력은 객체의 **행동**을 결정하고, 행동은 객체의 **상태**를 결정한다.

### 책임
- **책임**은 객체가 **협력에 참여**하기 위해 수행하는 **행동**이다.
- 책임은 크게 두 가지로 나뉜다:
  1. **무엇을 알고 있는가** (아는 것)
  2. **무엇을 할 수 있는가** (하는 것)

#### 책임 할당 시 고려 사항
1. **메시지가 객체를 결정한다**:
  - 객체는 **최소한의 인터페이스**만을 가질 수 있게 된다.
  - 충분히 **추상적인 인터페이스**를 유지할 수 있다.

2. **행동이 상태를 결정한다**:
  - 상태를 먼저 결정하고 필요한 행동을 결정하면, **객체 내부 구현**이 퍼블릭 인터페이스에 **노출**될 수 있어 **캡슐화가 저해**된다.

### 역할
- **역할**은 **다른 것으로 교체할 수 있는 책임의 집합**이다.

### 역할의 추상화
1. 세부 사항에 얽매이지 않고 **상위 수준의 정책**을 쉽게 표현할 수 있다.
2. 설계를 **유연**하게 만들 수 있다.
  - **동일한 책임**을 수행하는 객체들은 **동일한 역할**을 수행하며, 이로 인해 서로 **대체**가 가능하다.
  - 역할은 다양한 객체들이 **다양한 환경**에서 협력할 수 있도록 하여 협력을 **유연**하게 만든다.

---